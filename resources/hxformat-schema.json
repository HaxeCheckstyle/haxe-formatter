{
	"$schema": "http://json-schema.org/draft-07/schema#",
	"definitions": {
		"formatter.config.WhitespaceConfig": {
			"additionalProperties": false,
			"properties": {
				"ternaryPolicy": {
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "around"
				},
				"typeParamClosePolicy": {
					"description": "\">\"",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "none"
				},
				"caseColonPolicy": {
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "onlyAfter"
				},
				"intervalPolicy": {
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "none"
				},
				"commaPolicy": {
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "onlyAfter"
				},
				"typeCheckColonPolicy": {
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "around"
				},
				"typeParamOpenPolicy": {
					"description": "\"<\"",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "none"
				},
				"openingBracketPolicy": {
					"description": "\"[\"",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "noneAfter"
				},
				"closingBracketPolicy": {
					"description": "\"]\"",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "none"
				},
				"bracesConfig": {
					"description": "\"{\" + \"}\"",
					"$ref": "#/definitions/formatter.config.BracesWhitespaceConfig"
				},
				"compressSuccessiveParenthesis": {
					"description": "should formatter compress spaces for successive parenthesis `( [ {` vs. `([{`",
					"type": "boolean",
					"default": true
				},
				"functionTypeHaxe3Policy": {
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "none"
				},
				"arrowFunctionsPolicy": {
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "around"
				},
				"doPolicy": {
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "after"
				},
				"semicolonPolicy": {
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "onlyAfter"
				},
				"forPolicy": {
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "after"
				},
				"parenConfig": {
					"description": "\"(\" + \")\"",
					"$ref": "#/definitions/formatter.config.ParenWhitespaceConfig"
				},
				"objectFieldColonPolicy": {
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "after"
				},
				"colonPolicy": {
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "none"
				},
				"dotPolicy": {
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "none"
				},
				"switchPolicy": {
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "after"
				},
				"formatStringInterpolation": {
					"description": "should formatter try to format string interpolation expressions (e.g. '${x+3}' -> '${x + 3}') only applies spaces, no newlines or wrapping",
					"type": "boolean",
					"default": true
				},
				"typeExtensionPolicy": {
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "after"
				},
				"whilePolicy": {
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "after"
				},
				"typeHintColonPolicy": {
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "none"
				},
				"addLineCommentSpace": {
					"description": "ensure a space after '//'",
					"type": "boolean",
					"default": true
				},
				"catchPolicy": {
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "after"
				},
				"binopPolicy": {
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "around"
				},
				"ifPolicy": {
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "after"
				},
				"functionTypeHaxe4Policy": {
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "around"
				},
				"tryPolicy": {
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "after"
				}
			},
			"type": "object"
		},
		"formatter.config.WrappingLocation": {
			"anyOf": [
				{
					"const": "beforeLast"
				},
				{
					"const": "afterLast"
				}
			]
		},
		"formatter.config.InterfaceFieldsEmptyLinesConfig": {
			"additionalProperties": false,
			"properties": {
				"beginType": {
					"description": "add empty lines after opening \"{\" of type",
					"type": "integer",
					"default": 0
				},
				"betweenVars": {
					"type": "integer",
					"default": 0
				},
				"betweenFunctions": {
					"type": "integer",
					"default": 0
				},
				"afterVars": {
					"type": "integer",
					"default": 0
				},
				"existingBetweenFields": {
					"$ref": "#/definitions/formatter.config.KeepEmptyLinesPolicy",
					"default": "keep"
				},
				"endType": {
					"description": "add empty lines before closing \"}\" of type",
					"type": "integer",
					"default": 0
				}
			},
			"type": "object"
		},
		"formatter.config.ConditionalEmptyLinesConfig": {
			"additionalProperties": false,
			"properties": {
				"afterElse": {
					"type": "integer",
					"default": 0
				},
				"afterIf": {
					"type": "integer",
					"default": 0
				},
				"beforeElse": {
					"type": "integer",
					"default": 0
				},
				"beforeEnd": {
					"type": "integer",
					"default": 0
				},
				"beforeError": {
					"type": "integer",
					"default": 0
				},
				"afterError": {
					"type": "integer",
					"default": 0
				}
			},
			"type": "object"
		},
		"formatter.config.SharpLineEndPolicy": {
			"anyOf": [
				{
					"const": "none"
				},
				{
					"const": "after"
				}
			]
		},
		"formatter.config.WrapCondition": {
			"required": [
				"cond"
			],
			"additionalProperties": false,
			"properties": {
				"cond": {
					"$ref": "#/definitions/formatter.config.WrapConditionType"
				},
				"value": {
					"type": "integer",
					"default": 1
				}
			},
			"type": "object"
		},
		"formatter.config.EmptyCurlyPolicy": {
			"anyOf": [
				{
					"const": "noBreak"
				},
				{
					"const": "break"
				}
			]
		},
		"formatter.config.KeepEmptyLinesPolicy": {
			"anyOf": [
				{
					"const": "keep"
				},
				{
					"const": "remove"
				}
			]
		},
		"formatter.config.CaseColonLineEndPolicy": {
			"anyOf": [
				{
					"const": "none"
				},
				{
					"const": "after"
				}
			]
		},
		"formatter.config.WrapConfig": {
			"additionalProperties": false,
			"properties": {
				"opBoolChain": {
					"description": "OpBool chain wrapping rules",
					"$ref": "#/definitions/formatter.config.WrapRules"
				},
				"functionSignature": {
					"description": "named function signature wrapping rules",
					"$ref": "#/definitions/formatter.config.WrapRules"
				},
				"anonType": {
					"description": "anon types wrapping rules",
					"$ref": "#/definitions/formatter.config.WrapRules"
				},
				"methodChain": {
					"description": "method chaining wrapping rules",
					"$ref": "#/definitions/formatter.config.WrapRules"
				},
				"arrayWrap": {
					"description": "array wrapping rules does not affect array comprehension, use \"sameLine.comprehensionFor\"",
					"$ref": "#/definitions/formatter.config.WrapRules"
				},
				"maxLineLength": {
					"description": "maximum characters per line, formatter will try to wrap code longer than `maxLineLength`",
					"type": "integer",
					"default": 160
				},
				"callParameter": {
					"description": "call parameter wrapping rules",
					"$ref": "#/definitions/formatter.config.WrapRules"
				},
				"implementsExtends": {
					"description": "implements / extends chain wrapping rules",
					"$ref": "#/definitions/formatter.config.WrapRules"
				},
				"multiVar": {
					"description": "chain wrapping rules for OpAdd / OpSub",
					"$ref": "#/definitions/formatter.config.WrapRules"
				},
				"anonFunctionSignature": {
					"description": "anon function signature wrapping rules",
					"$ref": "#/definitions/formatter.config.WrapRules"
				},
				"casePattern": {
					"description": "chain wrapping rules for case patterns",
					"$ref": "#/definitions/formatter.config.WrapRules"
				},
				"typeParameter": {
					"description": "type parameter wrapping rules",
					"$ref": "#/definitions/formatter.config.WrapRules"
				},
				"opAddSubChain": {
					"description": "chain wrapping rules for OpAdd / OpSub",
					"$ref": "#/definitions/formatter.config.WrapRules"
				},
				"objectLiteral": {
					"description": "object literal wrapping rules",
					"$ref": "#/definitions/formatter.config.WrapRules"
				},
				"metadataCallParameter": {
					"description": "metadata call parameter wrapping rules",
					"$ref": "#/definitions/formatter.config.WrapRules"
				},
				"arrayMatrixWrap": {
					"description": "detect arrays in matrix configuration from source noMatrixWrap = no detection matrixWrapNoAlign = detect and format as matrix without alignment matrixWrapWithAlign = detect and format as matrix and align columns",
					"$ref": "#/definitions/formatter.config.ArrayMatrixWrap",
					"default": "matrixWrapWithAlign"
				}
			},
			"type": "object"
		},
		"formatter.config.ConditionalIndentationPolicy": {
			"anyOf": [
				{
					"const": "fixedZero"
				},
				{
					"const": "fixedZeroIncrease"
				},
				{
					"const": "fixedZeroIncreaseBlocks"
				},
				{
					"const": "aligned"
				},
				{
					"const": "alignedNestedIncrease"
				},
				{
					"const": "alignedIncrease"
				},
				{
					"const": "alignedDecrease"
				}
			]
		},
		"formatter.config.ImportsEmptyLinesConfig": {
			"additionalProperties": false,
			"properties": {
				"betweenImports": {
					"description": "empty lines between two consecutive import/using lines using betweenImportsLevel",
					"type": "integer",
					"default": 0
				},
				"betweenImportsLevel": {
					"description": "restrict betweenImports setting to a specific level \"all\" - apply betweenImports to all imports/using entries \"firstLevelPackage\" - group imports/using entries using toplevel package names; no empty lines for identical toplevel names \"secondLevelPackage\" - group imports/using entries using top- and secondlevel package names; no empty lines for identical toplevel and secondlevel names \"thirdLevelPackage\" - group imports/using entries using upto thirdlevel package names \"fourthLevelPackage\" - group imports/using entries using upto foruthlevel package names \"fifthLevelPackage\" - group imports/using entries using upto fifthlevel package names \"fullPackage\" - group imports/using entries using full packages; no empty lines for identical package names",
					"$ref": "#/definitions/formatter.config.BetweenImportsEmptyLinesLevel",
					"default": "all"
				},
				"beforeUsing": {
					"description": "empty lines between import and using lines",
					"type": "integer",
					"default": 1
				},
				"beforeType": {
					"description": "empty lines after import and using section",
					"type": "integer",
					"default": 1
				}
			},
			"type": "object"
		},
		"formatter.config.SameLinePolicy": {
			"anyOf": [
				{
					"const": "same"
				},
				{
					"const": "next"
				},
				{
					"const": "keep"
				}
			]
		},
		"formatter.config.LeftCurlyLineEndPolicy": {
			"anyOf": [
				{
					"const": "none"
				},
				{
					"const": "after"
				},
				{
					"const": "before"
				},
				{
					"const": "both"
				}
			]
		},
		"formatter.config.ClassFieldsEmptyLinesConfig": {
			"additionalProperties": false,
			"properties": {
				"beginType": {
					"description": "add empty lines after opening \"{\" of type",
					"type": "integer",
					"default": 0
				},
				"afterStaticFunctions": {
					"type": "integer",
					"default": 1
				},
				"betweenStaticFunctions": {
					"type": "integer",
					"default": 1
				},
				"betweenVars": {
					"type": "integer",
					"default": 0
				},
				"afterStaticVars": {
					"type": "integer",
					"default": 1
				},
				"betweenFunctions": {
					"type": "integer",
					"default": 1
				},
				"afterVars": {
					"type": "integer",
					"default": 1
				},
				"afterPrivateFunctions": {
					"type": "integer",
					"default": 1
				},
				"existingBetweenFields": {
					"$ref": "#/definitions/formatter.config.KeepEmptyLinesPolicy",
					"default": "keep"
				},
				"endType": {
					"description": "add empty lines before closing \"}\" of type",
					"type": "integer",
					"default": 0
				},
				"afterPrivateVars": {
					"type": "integer",
					"default": 1
				},
				"betweenStaticVars": {
					"type": "integer",
					"default": 0
				}
			},
			"type": "object"
		},
		"formatter.config.RightCurlyLineEndPolicy": {
			"anyOf": [
				{
					"const": "none"
				},
				{
					"const": "before"
				},
				{
					"const": "after"
				},
				{
					"const": "both"
				}
			]
		},
		"formatter.config.CommentEmptyLinesPolicy": {
			"anyOf": [
				{
					"const": "ignore"
				},
				{
					"const": "none"
				},
				{
					"const": "one"
				}
			]
		},
		"formatter.config.LineCommentEmptyLinePolicy": {
			"anyOf": [
				{
					"const": "keep"
				},
				{
					"const": "one"
				},
				{
					"const": "none"
				}
			]
		},
		"formatter.config.FormatterConfig": {
			"additionalProperties": false,
			"properties": {
				"disableFormatting": {
					"description": "turns off formatting for all files in current folder and subfolders unless subfolder contains a `hxformat.json`",
					"type": "boolean",
					"default": false
				},
				"excludes": {
					"description": "regular expressions matching files to exclude from formatting default is to exclude any `.haxelib`, `.git` and `node_modules` folder",
					"items": {
						"type": "string"
					},
					"type": "array"
				},
				"indentation": {
					"$ref": "#/definitions/formatter.config.IndentationConfig"
				},
				"emptyLines": {
					"$ref": "#/definitions/formatter.config.EmptyLinesConfig"
				},
				"lineEnds": {
					"$ref": "#/definitions/formatter.config.LineEndConfig"
				},
				"sameLine": {
					"$ref": "#/definitions/formatter.config.SameLineConfig"
				},
				"wrapping": {
					"$ref": "#/definitions/formatter.config.WrapConfig"
				},
				"whitespace": {
					"$ref": "#/definitions/formatter.config.WhitespaceConfig"
				}
			},
			"type": "object"
		},
		"formatter.config.CurlyLineEndPolicy": {
			"additionalProperties": false,
			"properties": {
				"rightCurly": {
					"description": "line end options for right curly",
					"$ref": "#/definitions/formatter.config.RightCurlyLineEndPolicy",
					"default": "both"
				},
				"emptyCurly": {
					"description": "line end options for empty curlies",
					"$ref": "#/definitions/formatter.config.EmptyCurlyPolicy",
					"default": "noBreak"
				},
				"leftCurly": {
					"description": "line end options for left curly",
					"$ref": "#/definitions/formatter.config.LeftCurlyLineEndPolicy",
					"default": "after"
				}
			},
			"type": "object"
		},
		"formatter.config.WrapConditionType": {
			"anyOf": [
				{
					"description": "condition matches if item count is larger than or equal n characters",
					"const": "itemCount >= n"
				},
				{
					"description": "condition matches if item count is less than or equal n characters",
					"const": "itemCount <= n"
				},
				{
					"description": "condition matches if max item length is larger than or equal n characters",
					"const": "anyItemLength >= n"
				},
				{
					"description": "condition matches if max item length is less than or equal n characters",
					"const": "anyItemLength <= n"
				},
				{
					"description": "condition matches if total length of all wrapable items is larger than or equal n characters",
					"const": "totalItemLength >= n"
				},
				{
					"description": "condition matches if total length of all wrapable items is less than or equal n characters",
					"const": "totalItemLength <= n"
				},
				{
					"description": "condition matches lines larger than or equal n characters",
					"const": "lineLength >= n"
				},
				{
					"description": "condition matches lines less than or equal n characters",
					"const": "lineLength <= n"
				},
				{
					"description": "condition value = 1 matches if line contains a multiline token (string literal, block comment) value = 0 matches if no multiline token is present",
					"const": "hasMultilineItems"
				},
				{
					"description": "condition value = 1 matches if unwrapped line exceeds maxLineLength value = 0 matches unwrapped lines not exceeding maxLineLength",
					"const": "exceedsMaxLineLength"
				}
			]
		},
		"formatter.config.LineEndConfig": {
			"additionalProperties": false,
			"properties": {
				"typedefCurly": {
					"description": "line end settings for typedef curlies",
					"$ref": "#/definitions/formatter.config.CurlyLineEndPolicy"
				},
				"metadataVar": {
					"$ref": "#/definitions/formatter.config.AtLineEndPolicy",
					"default": "none"
				},
				"metadataFunction": {
					"$ref": "#/definitions/formatter.config.AtLineEndPolicy",
					"default": "none"
				},
				"anonTypeCurly": {
					"description": "line end settings for anon type curlies",
					"$ref": "#/definitions/formatter.config.CurlyLineEndPolicy"
				},
				"rightCurly": {
					"description": "global right curly line end setting",
					"$ref": "#/definitions/formatter.config.RightCurlyLineEndPolicy",
					"default": "both"
				},
				"caseColon": {
					"$ref": "#/definitions/formatter.config.CaseColonLineEndPolicy",
					"default": "after"
				},
				"lineEndCharacter": {
					"description": "line end character to use when outputting formatted code",
					"$ref": "#/definitions/formatter.config.LineEndCharacter",
					"default": "auto"
				},
				"objectLiteralCurly": {
					"description": "line end settings for object literal curlies",
					"$ref": "#/definitions/formatter.config.CurlyLineEndPolicy"
				},
				"anonFunctionCurly": {
					"description": "line end settings for anon function body curlies",
					"$ref": "#/definitions/formatter.config.CurlyLineEndPolicy"
				},
				"metadataType": {
					"$ref": "#/definitions/formatter.config.AtLineEndPolicy",
					"default": "none"
				},
				"sharp": {
					"$ref": "#/definitions/formatter.config.SharpLineEndPolicy",
					"default": "after"
				},
				"emptyCurly": {
					"description": "global empty curlies line end setting",
					"$ref": "#/definitions/formatter.config.EmptyCurlyPolicy",
					"default": "noBreak"
				},
				"leftCurly": {
					"description": "global left curly line end setting",
					"$ref": "#/definitions/formatter.config.LeftCurlyLineEndPolicy",
					"default": "after"
				},
				"blockCurly": {
					"description": "line end settings for block curlies",
					"$ref": "#/definitions/formatter.config.CurlyLineEndPolicy"
				},
				"metadataOther": {
					"$ref": "#/definitions/formatter.config.AtLineEndPolicy",
					"default": "none"
				}
			},
			"type": "object"
		},
		"formatter.config.SameLineConfig": {
			"additionalProperties": false,
			"properties": {
				"tryBody": {
					"description": "same line policy for non block body of \"try\" * same = place try and body on same line * next = place body on next line * keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy",
					"default": "next"
				},
				"comprehensionFor": {
					"$ref": "#/definitions/formatter.config.SameLinePolicy",
					"default": "same"
				},
				"returnBodySingleLine": {
					"description": "same line policy for single line expression return values * same = place return and body on same line * next = place body on next line * keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy",
					"default": "same"
				},
				"ifElse": {
					"description": "same line policy for \"else\" part of \"if…else\" * same = place else and body on same line * next = place body on next line * keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy",
					"default": "same"
				},
				"expressionCase": {
					"$ref": "#/definitions/formatter.config.SameLinePolicy",
					"default": "keep"
				},
				"expressionTry": {
					"$ref": "#/definitions/formatter.config.SameLinePolicy",
					"default": "same"
				},
				"doWhile": {
					"description": "same line policy for \"while\" part in \"do…while\" * same = place while and body on same line * next = place body on next line * keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy",
					"default": "same"
				},
				"expressionIfWithBlocks": {
					"description": "will place if with one expression in a block in one line (requires \"expressionIf\" = \"same\") var foo = if (bar) { \"\"; } else { \"\"; };",
					"type": "boolean",
					"default": false
				},
				"catchBody": {
					"description": "same line policy for non block body of \"catch\" * same = place catch and body on same line * next = place body on next line * keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy",
					"default": "next"
				},
				"elseIf": {
					"description": "same line policy for \"if\" part of \"else if\" * same = place if and body on same line * next = place body on next line * keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy",
					"default": "same"
				},
				"functionBody": {
					"description": "same line policy for non block body of \"function\" * same = place function and body on same line * next = place body on next line * keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy",
					"default": "next"
				},
				"expressionIf": {
					"description": "same line policy for non block body of \"if\" in a value place / as expression * same = place if and body on same line * next = place body on next line * keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy",
					"default": "same"
				},
				"ifBody": {
					"description": "same line policy for non block body of \"if\" * same = place if and body on same line * next = place body on next line * keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy",
					"default": "next"
				},
				"caseBody": {
					"$ref": "#/definitions/formatter.config.SameLinePolicy",
					"default": "next"
				},
				"elseBody": {
					"description": "same line policy for non block body of \"else\" * same = place else and body on same line * next = place body on next line * keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy",
					"default": "next"
				},
				"tryCatch": {
					"description": "same line policy for \"catch\" part of \"try…catch\" * same = place function and body on same line * next = place body on next line * keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy",
					"default": "same"
				},
				"doWhileBody": {
					"description": "same line policy for non block body of \"do…while\" * same = place function and body on same line * next = place body on next line * keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy",
					"default": "next"
				},
				"returnBody": {
					"description": "same line policy for multiline expression return values * same = place return and body on same line * next = place body on next line * keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy",
					"default": "same"
				},
				"untypedBody": {
					"description": "same line policy for untyped {…} as a body * same = place return and body on same line * next = place body on next line * keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy",
					"default": "same"
				},
				"anonFunctionBody": {
					"description": "same line policy for non block body of anon \"function\" * same = place function and body on same line * next = place body on next line * keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy",
					"default": "same"
				},
				"forBody": {
					"description": "same line policy for non block body of \"for\" * same = place function and body on same line * next = place body on next line * keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy",
					"default": "next"
				},
				"whileBody": {
					"description": "same line policy for non block body of \"while\" (not \"do…while\") * same = place while and body on same line * next = place body on next line * keep = keep same / next line from source",
					"$ref": "#/definitions/formatter.config.SameLinePolicy",
					"default": "next"
				}
			},
			"type": "object"
		},
		"formatter.config.EmptyLinesConfig": {
			"additionalProperties": false,
			"properties": {
				"beforeRightCurly": {
					"description": "Remove or keep empty lines above \"}\"",
					"$ref": "#/definitions/formatter.config.KeepEmptyLinesPolicy",
					"default": "remove"
				},
				"afterLeftCurly": {
					"description": "Remove or keep empty lines below \"{\"",
					"$ref": "#/definitions/formatter.config.KeepEmptyLinesPolicy",
					"default": "remove"
				},
				"afterReturn": {
					"description": "Remove or keep empty lines below \"return\"",
					"$ref": "#/definitions/formatter.config.KeepEmptyLinesPolicy",
					"default": "remove"
				},
				"afterPackage": {
					"description": "empty lines after package declaration",
					"type": "integer",
					"default": 1
				},
				"macroClassEmptyLines": {
					"$ref": "#/definitions/formatter.config.ClassFieldsEmptyLinesConfig"
				},
				"betweenMultilineComments": {
					"description": "Adds empty lines between two consecutive multiline comments",
					"type": "integer",
					"default": 0
				},
				"afterFieldsWithDocComments": {
					"description": "\"one\" adds one empty line after fields with doc comments \"none\" removes all empty lines line fields with doc comments \"ignore\" respects empty lines set via \"betweenVars\", \"betweenFunctions\", etc.",
					"$ref": "#/definitions/formatter.config.CommentEmptyLinesPolicy",
					"default": "one"
				},
				"finalNewline": {
					"description": "adds a final newline",
					"type": "boolean",
					"default": true
				},
				"importAndUsing": {
					"description": "empty lines for package, import and using section",
					"$ref": "#/definitions/formatter.config.ImportsEmptyLinesConfig"
				},
				"beforeBlocks": {
					"$ref": "#/definitions/formatter.config.KeepEmptyLinesPolicy",
					"default": "remove"
				},
				"betweenSingleLineTypes": {
					"description": "empty lines between two single line types",
					"type": "integer",
					"default": 0
				},
				"conditionalsEmptyLines": {
					"$ref": "#/definitions/formatter.config.ConditionalEmptyLinesConfig"
				},
				"afterBlocks": {
					"$ref": "#/definitions/formatter.config.KeepEmptyLinesPolicy",
					"default": "remove"
				},
				"enumEmptyLines": {
					"$ref": "#/definitions/formatter.config.TypedefFieldsEmptyLinesConfig"
				},
				"externClassEmptyLines": {
					"$ref": "#/definitions/formatter.config.InterfaceFieldsEmptyLinesConfig"
				},
				"betweenTypes": {
					"description": "empty lines between types",
					"type": "integer",
					"default": 1
				},
				"maxAnywhereInFile": {
					"description": "maximum consecutive empty lines anywhere in file - runs last, all empty lines policies are limited to \"maxAnywhereInFile\"",
					"type": "integer",
					"default": 1
				},
				"typedefEmptyLines": {
					"$ref": "#/definitions/formatter.config.TypedefFieldsEmptyLinesConfig"
				},
				"enumAbstractEmptyLines": {
					"$ref": "#/definitions/formatter.config.EnumAbstractFieldsEmptyLinesConfig"
				},
				"lineCommentsBetweenTypes": {
					"description": "empty lines for line comments between types",
					"$ref": "#/definitions/formatter.config.LineCommentEmptyLinePolicy",
					"default": "keep"
				},
				"abstractEmptyLines": {
					"$ref": "#/definitions/formatter.config.ClassFieldsEmptyLinesConfig"
				},
				"beforePackage": {
					"description": "empty lines before package declaration",
					"type": "integer",
					"default": 0
				},
				"classEmptyLines": {
					"$ref": "#/definitions/formatter.config.ClassFieldsEmptyLinesConfig"
				},
				"beforeDocCommentEmptyLines": {
					"description": "\"one\" adds one empty line above doc comments \"none\" removes all empty lines above doc comments \"ignore\" respects empty lines set via \"betweenVars\", \"betweenFunctions\", etc.",
					"$ref": "#/definitions/formatter.config.CommentEmptyLinesPolicy",
					"default": "one"
				},
				"interfaceEmptyLines": {
					"$ref": "#/definitions/formatter.config.InterfaceFieldsEmptyLinesConfig"
				},
				"afterFileHeaderComment": {
					"description": "Adds empty lines when file starts with a multiline comment",
					"type": "integer",
					"default": 1
				},
				"lineCommentsBetweenFunctions": {
					"description": "empty lines for line comments between functions",
					"$ref": "#/definitions/formatter.config.LineCommentEmptyLinePolicy",
					"default": "keep"
				}
			},
			"type": "object"
		},
		"formatter.config.BetweenImportsEmptyLinesLevel": {
			"anyOf": [
				{
					"const": "all"
				},
				{
					"const": "firstLevelPackage"
				},
				{
					"const": "secondLevelPackage"
				},
				{
					"const": "thirdLevelPackage"
				},
				{
					"const": "fourthLevelPackage"
				},
				{
					"const": "fifthLevelPackage"
				},
				{
					"const": "fullPackage"
				}
			]
		},
		"formatter.config.EnumAbstractFieldsEmptyLinesConfig": {
			"additionalProperties": false,
			"properties": {
				"beginType": {
					"description": "add empty lines after opening \"{\" of type",
					"type": "integer",
					"default": 0
				},
				"betweenVars": {
					"type": "integer",
					"default": 0
				},
				"betweenFunctions": {
					"type": "integer",
					"default": 1
				},
				"afterVars": {
					"type": "integer",
					"default": 1
				},
				"existingBetweenFields": {
					"$ref": "#/definitions/formatter.config.KeepEmptyLinesPolicy",
					"default": "keep"
				},
				"endType": {
					"description": "add empty lines before closing \"}\" of type",
					"type": "integer",
					"default": 0
				}
			},
			"type": "object"
		},
		"formatter.config.WrappingType": {
			"anyOf": [
				{
					"description": "every item in a separate line, including first item",
					"const": "onePerLine"
				},
				{
					"description": "every item in a separate line, except first item",
					"const": "onePerLineAfterFirst"
				},
				{
					"description": "put an equal amount of items per line - not yet implemented",
					"const": "equalNumber"
				},
				{
					"description": "fill each line until maxLineLength - does not start with a newline",
					"const": "fillLine"
				},
				{
					"description": "fill each line until maxLineLength, starts with a newline before first item",
					"const": "fillLineWithLeadingBreak"
				},
				{
					"description": "do not wrap items",
					"const": "noWrap"
				},
				{
					"description": "use wrapping information from source",
					"const": "keep"
				}
			]
		},
		"formatter.config.ParenWhitespaceConfig": {
			"additionalProperties": false,
			"properties": {
				"sharpConditionParens": {
					"description": "parens used for sharp conditions",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"metadataParens": {
					"description": "parens used for metadata",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"whileConditionParens": {
					"description": "parens used for while conditions",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"catchParens": {
					"description": "parens used for catch",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"switchConditionParens": {
					"description": "parens used for switch conditions",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"callParens": {
					"description": "parens used for calls",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"ifConditionParens": {
					"description": "parens used for if conditions",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"forLoopParens": {
					"description": "parens used for for loops",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"anonFuncParamParens": {
					"description": "parens used for anon function parameters",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"conditionParens": {
					"description": "parens used for conditions",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"expressionParens": {
					"description": "parens used for expressions",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"funcParamParens": {
					"description": "parens used for function parameters",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				}
			},
			"type": "object"
		},
		"formatter.config.IndentationConfig": {
			"additionalProperties": false,
			"properties": {
				"indentObjectLiteral": {
					"type": "boolean",
					"default": true
				},
				"indentCaseLabels": {
					"description": "indent case / default labels (true) or keep them on same level as switch (false)",
					"type": "boolean",
					"default": true
				},
				"character": {
					"description": "use \"tab\", \" \", \"  \", \"   \", \"    \", etc. to define which character to use",
					"type": "string",
					"default": "tab"
				},
				"conditionalPolicy": {
					"description": "only applies to non inlined conditionals \"fixedZero\" = all conditional statements should start in column 1 \"fixedZeroIncrease\" = indentation for conditionals starts at 0 and increases for every level \"fixedZeroIncreaseBlocks\" = same as \"fixedZeroIncrease\" but increases only inside blocks, outside it's \"fixedZero\" \"aligned\" = conditional statements share indentation of surrounding code \"alignedNestedIncrease\" = conditionals align with surrounding code, but will increase indent when nested \"alignedIncrease\" = same as \"aligned\" but will increase indent by +1 for enclosed code \"alignedDecrease\" = same as \"aligned\" but will decrease indent by -1 for enclosed code",
					"$ref": "#/definitions/formatter.config.ConditionalIndentationPolicy",
					"default": "aligned"
				},
				"tabWidth": {
					"description": "if `character` is set to \"tab\", formatter uses `tabWidth` to calculate absolute line length",
					"type": "integer",
					"default": 4
				},
				"trailingWhitespace": {
					"description": "adds trailing whitespace to empty lines by copying indentation from preceeding line",
					"type": "boolean",
					"default": false
				},
				"indentComplexValueExpressions": {
					"description": "indent complex value expressions: (true)\t\t\t\t\t\t(false) var a = if (true)\t\t\tvar a = if (true) 10;\t\t\t\t\t\t10; else\t\t\t\t\telse 20;\t\t\tvs.\t\t\t20; return if (true)\t\t\treturn if (true) 10;\t\t\t\t\t\t10; else\t\t\t\t\telse 20;\t\t\t\t\t\t20;",
					"type": "boolean",
					"default": false
				}
			},
			"type": "object"
		},
		"formatter.config.LineEndCharacter": {
			"anyOf": [
				{
					"description": "detect line end character from input (repeated for each input file)",
					"const": "auto"
				},
				{
					"description": "output files with \\r line endings",
					"const": "CR"
				},
				{
					"description": "output files with \\n line endings",
					"const": "LF"
				},
				{
					"description": "output files with \\r\\n line endings",
					"const": "CRLF"
				}
			]
		},
		"formatter.config.BracesWhitespaceConfig": {
			"additionalProperties": false,
			"properties": {
				"objectLiteralBraces": {
					"description": "braces for object literals",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"unknownBraces": {
					"description": "unknown braces",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"blockBraces": {
					"description": "braces for blocks",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"typedefBraces": {
					"description": "braces for typdefs",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				},
				"anonTypeBraces": {
					"description": "braces for anon types",
					"$ref": "#/definitions/formatter.config.OpenClosePolicy"
				}
			},
			"type": "object"
		},
		"formatter.config.WrapRule": {
			"required": [
				"conditions",
				"type"
			],
			"additionalProperties": false,
			"properties": {
				"conditions": {
					"description": "list of conditions wrapping selects a rule if all of its conditions evaluate to true",
					"items": {
						"$ref": "#/definitions/formatter.config.WrapCondition"
					},
					"type": "array"
				},
				"additionalIndent": {
					"description": "adds indentation to all wrapped lines",
					"type": "integer",
					"default": 0
				},
				"location": {
					"description": "default wrapping location before / after last token",
					"$ref": "#/definitions/formatter.config.WrappingLocation",
					"default": "afterLast"
				},
				"type": {
					"description": "wrapping type",
					"$ref": "#/definitions/formatter.config.WrappingType"
				}
			},
			"type": "object"
		},
		"formatter.config.OpenClosePolicy": {
			"additionalProperties": false,
			"properties": {
				"closingPolicy": {
					"description": "\")\"",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "onlyAfter"
				},
				"removeInnerWhenEmpty": {
					"description": "\"()\" or \"( )\" - if `openingPolicy` contains `After` or `closingPolicy` contains `Before`",
					"type": "boolean",
					"default": true
				},
				"openingPolicy": {
					"description": "\"(\"",
					"$ref": "#/definitions/formatter.config.WhitespacePolicy",
					"default": "none"
				}
			},
			"type": "object"
		},
		"formatter.config.WrapRules": {
			"additionalProperties": false,
			"properties": {
				"defaultWrap": {
					"description": "default wrapping type when no rule applies",
					"$ref": "#/definitions/formatter.config.WrappingType",
					"default": "noWrap"
				},
				"defaultLocation": {
					"description": "default wrapping location before / after last token",
					"$ref": "#/definitions/formatter.config.WrappingLocation",
					"default": "afterLast"
				},
				"defaultAdditionalIndent": {
					"description": "adds indentation to all wrapped lines when applying defaultWrap",
					"type": "integer",
					"default": 0
				},
				"rules": {
					"description": "list of wrapping rules wrapping uses only the first rule whose conditions evaluates to true",
					"items": {
						"$ref": "#/definitions/formatter.config.WrapRule"
					},
					"type": "array"
				}
			},
			"type": "object"
		},
		"formatter.config.TypedefFieldsEmptyLinesConfig": {
			"additionalProperties": false,
			"properties": {
				"beginType": {
					"description": "add empty lines after opening \"{\" of type",
					"type": "integer",
					"default": 0
				},
				"betweenFields": {
					"type": "integer",
					"default": 0
				},
				"existingBetweenFields": {
					"$ref": "#/definitions/formatter.config.KeepEmptyLinesPolicy",
					"default": "keep"
				},
				"endType": {
					"description": "add empty lines before closing \"}\" of type",
					"type": "integer",
					"default": 0
				}
			},
			"type": "object"
		},
		"formatter.config.AtLineEndPolicy": {
			"anyOf": [
				{
					"const": "none"
				},
				{
					"const": "after"
				},
				{
					"const": "afterLast"
				},
				{
					"const": "forceAfterLast"
				}
			]
		},
		"formatter.config.ArrayMatrixWrap": {
			"anyOf": [
				{
					"const": "noMatrixWrap"
				},
				{
					"const": "matrixWrapNoAlign"
				},
				{
					"const": "matrixWrapWithAlign"
				}
			]
		},
		"formatter.config.WhitespacePolicy": {
			"anyOf": [
				{
					"const": "none"
				},
				{
					"const": "before"
				},
				{
					"const": "noneBefore"
				},
				{
					"const": "onlyBefore"
				},
				{
					"const": "after"
				},
				{
					"const": "onlyAfter"
				},
				{
					"const": "noneAfter"
				},
				{
					"const": "around"
				}
			]
		}
	},
	"$ref": "#/definitions/formatter.config.FormatterConfig"
}