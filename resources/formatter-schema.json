{
	"id": "https://raw.githubusercontent.com/HaxeCheckstyle/haxe-formatter/master/resources/formatter-schema.json",
	"$ref": "#/definitions/FormatterConfig",
	"$schema": "http://json-schema.org/schema#",
	"definitions": {
		"FormatterConfig": {
			"type": "object",
			"properties": {
				"whitespace": {
					"propertyOrder": 5,
					"$ref": "#/definitions/WhitespaceConfig"
				},
				"indentation": {
					"propertyOrder": 2,
					"$ref": "#/definitions/IndentationConfig"
				},
				"sameLine": {
					"propertyOrder": 4,
					"$ref": "#/definitions/SameLineConfig"
				},
				"disableFormatting": {
					"type": "boolean",
					"description": "turns off formatting for all files in current folder and subfolders\n\t\tunless subfolder contains a \"hxformat.json\"",
					"propertyOrder": 0
				},
				"emptyLines": {
					"propertyOrder": 1,
					"$ref": "#/definitions/EmptyLinesConfig"
				},
				"lineEnds": {
					"propertyOrder": 3,
					"$ref": "#/definitions/LineEndConfig"
				},
				"excludes": {
					"items": {
						"type": "string"
					},
					"type": "array",
					"description": "regular expressions matching files to exclude from formatting\n\t\tdefault ist to exclude any \".haxelib\" folder",
					"propertyOrder": 7
				},
				"wrapping": {
					"propertyOrder": 6,
					"$ref": "#/definitions/WrapConfig"
				}
			},
			"additionalProperties": false
		},
		"InterfaceFieldsEmptyLinesConfig": {
			"type": "object",
			"properties": {
				"afterVars": {
					"type": "integer",
					"propertyOrder": 3
				},
				"betweenFunctions": {
					"type": "integer",
					"propertyOrder": 4
				},
				"beginType": {
					"type": "integer",
					"description": "add empty lines after opening \"{\" of type",
					"propertyOrder": 0
				},
				"endType": {
					"type": "integer",
					"description": "add empty lines before closing \"}\" of type",
					"propertyOrder": 1
				},
				"betweenVars": {
					"type": "integer",
					"propertyOrder": 2
				}
			},
			"additionalProperties": false
		},
		"IndentationConfig": {
			"type": "object",
			"properties": {
				"character": {
					"type": "string",
					"description": "use \"tab\" or \"<amount of spaces per indent in spaces>\" to define which character to use",
					"propertyOrder": 1
				},
				"trailingWhitespace": {
					"type": "boolean",
					"description": "adds trailing whitespace to empty lines by copying indentation from preceeding line",
					"propertyOrder": 3
				},
				"tabWidth": {
					"type": "integer",
					"description": "if `character` is set to \"tab\", formatter uses `tabWidth` to calculate absolute line length",
					"propertyOrder": 2
				},
				"indentObjectLiteral": {
					"type": "boolean",
					"propertyOrder": 4
				},
				"conditionalPolicy": {
					"enum": [
						"fixedZero",
						"aligned",
						"alignedIncrease",
						"alignedDecrease"
					],
					"type": "string",
					"description": "only applies to non inlined conditionals\n\t\t\"fixedZero\" = all conditional statements should start in column 1\n\t\t\"aligned\" = conditional statements share indentation of surrounding code\n\t\t\"alignedIncrease\" = same as \"aligned\" but will increase indent by +1 for enclosed code",
					"propertyOrder": 0
				}
			},
			"additionalProperties": false
		},
		"TypedefFieldsEmptyLinesConfig": {
			"type": "object",
			"properties": {
				"betweenFields": {
					"type": "integer",
					"propertyOrder": 2
				},
				"beginType": {
					"type": "integer",
					"description": "add empty lines after opening \"{\" of type",
					"propertyOrder": 0
				},
				"endType": {
					"type": "integer",
					"description": "add empty lines before closing \"}\" of type",
					"propertyOrder": 1
				}
			},
			"additionalProperties": false
		},
		"WrapRule": {
			"type": "object",
			"properties": {
				"type": {
					"enum": [
						"onePerLine",
						"onePerLineAfterFirst",
						"equalNumber",
						"fillLine",
						"noWrap",
						"keep"
					],
					"type": "string",
					"description": "wrapping type",
					"propertyOrder": 1
				},
				"additionalIndent": {
					"type": "integer",
					"description": "adds indentation to all wrapped lines",
					"propertyOrder": 2
				},
				"conditions": {
					"items": {
						"$ref": "#/definitions/WrapCondition"
					},
					"type": "array",
					"description": "list of conditions\n\t\twrapping selects a rule if all of its conditions evaluate to true",
					"propertyOrder": 0
				}
			},
			"additionalProperties": false,
			"required": [
				"conditions",
				"type"
			]
		},
		"SameLineConfig": {
			"type": "object",
			"properties": {
				"forBody": {
					"enum": [
						"same",
						"next",
						"keep"
					],
					"type": "string",
					"description": "same line policy for non block body of \"for\"\n\t\t* same = place function and body on same line\n\t\t* next = place body on next line\n\t\t* keep = keep same / next line from source",
					"propertyOrder": 6
				},
				"tryBody": {
					"enum": [
						"same",
						"next",
						"keep"
					],
					"type": "string",
					"description": "same line policy for non block body of \"try\"\n\t\t* same = place function and body on same line\n\t\t* next = place body on next line\n\t\t* keep = keep same / next line from source",
					"propertyOrder": 11
				},
				"anonFunctionBody": {
					"enum": [
						"same",
						"next",
						"keep"
					],
					"type": "string",
					"description": "same line policy for non block body of anon \"function\"\n\t\t* same = place function and body on same line\n\t\t* next = place body on next line\n\t\t* keep = keep same / next line from source",
					"propertyOrder": 18
				},
				"whileBody": {
					"enum": [
						"same",
						"next",
						"keep"
					],
					"type": "string",
					"description": "same line policy for non block body of \"while\" (not \"do…while\")\n\t\t* same = place function and body on same line\n\t\t* next = place body on next line\n\t\t* keep = keep same / next line from source",
					"propertyOrder": 8
				},
				"returnBody": {
					"enum": [
						"same",
						"next",
						"keep"
					],
					"type": "string",
					"description": "same line policy for return values\n\t\t* same = place function and body on same line\n\t\t* next = place body on next line\n\t\t* keep = keep same / next line from source",
					"propertyOrder": 19
				},
				"elseIf": {
					"enum": [
						"same",
						"next",
						"keep"
					],
					"type": "string",
					"description": "same line policy for \"if\" part of \"else if\"\n\t\t* same = place function and body on same line\n\t\t* next = place body on next line\n\t\t* keep = keep same / next line from source",
					"propertyOrder": 3
				},
				"expressionIf": {
					"enum": [
						"same",
						"next",
						"keep"
					],
					"type": "string",
					"description": "same line policy for non block body of \"if\" in a value place / as expression\n\t\t* same = place function and body on same line\n\t\t* next = place body on next line\n\t\t* keep = keep same / next line from source",
					"propertyOrder": 4
				},
				"ifBody": {
					"enum": [
						"same",
						"next",
						"keep"
					],
					"type": "string",
					"description": "same line policy for non block body of \"if\"\n\t\t* same = place function and body on same line\n\t\t* next = place body on next line\n\t\t* keep = keep same / next line from source",
					"propertyOrder": 0
				},
				"ifElse": {
					"enum": [
						"same",
						"next",
						"keep"
					],
					"type": "string",
					"description": "same line policy for \"else\" part of \"if…else\"\n\t\t* same = place function and body on same line\n\t\t* next = place body on next line\n\t\t* keep = keep same / next line from source",
					"propertyOrder": 2
				},
				"elseBody": {
					"enum": [
						"same",
						"next",
						"keep"
					],
					"type": "string",
					"description": "same line policy for non block body of \"else\"\n\t\t* same = place function and body on same line\n\t\t* next = place body on next line\n\t\t* keep = keep same / next line from source",
					"propertyOrder": 1
				},
				"expressionCase": {
					"enum": [
						"same",
						"next",
						"keep"
					],
					"type": "string",
					"propertyOrder": 15
				},
				"comprehensionFor": {
					"enum": [
						"same",
						"next",
						"keep"
					],
					"type": "string",
					"propertyOrder": 7
				},
				"expressionIfWithBlocks": {
					"type": "boolean",
					"description": "will place if with one expression in a block in one line (requires \"expressionIf\" = \"same\")\n\t\tvar foo = if (bar) { \"\"; } else { \"\"; };",
					"propertyOrder": 5
				},
				"doWhile": {
					"enum": [
						"same",
						"next",
						"keep"
					],
					"type": "string",
					"description": "same line policy for \"while\" part in \"do…while\"\n\t\t* same = place function and body on same line\n\t\t* next = place body on next line\n\t\t* keep = keep same / next line from source",
					"propertyOrder": 10
				},
				"expressionTry": {
					"enum": [
						"same",
						"next",
						"keep"
					],
					"type": "string",
					"propertyOrder": 16
				},
				"tryCatch": {
					"enum": [
						"same",
						"next",
						"keep"
					],
					"type": "string",
					"description": "same line policy for \"catch\" part of \"try…catch\"\n\t\t* same = place function and body on same line\n\t\t* next = place body on next line\n\t\t* keep = keep same / next line from source",
					"propertyOrder": 13
				},
				"functionBody": {
					"enum": [
						"same",
						"next",
						"keep"
					],
					"type": "string",
					"description": "same line policy for non block body of \"function\"\n\t\t* same = place function and body on same line\n\t\t* next = place body on next line\n\t\t* keep = keep same / next line from source",
					"propertyOrder": 17
				},
				"caseBody": {
					"enum": [
						"same",
						"next",
						"keep"
					],
					"type": "string",
					"propertyOrder": 14
				},
				"doWhileBody": {
					"enum": [
						"same",
						"next",
						"keep"
					],
					"type": "string",
					"description": "same line policy for non block body of \"do…while\"\n\t\t* same = place function and body on same line\n\t\t* next = place body on next line\n\t\t* keep = keep same / next line from source",
					"propertyOrder": 9
				},
				"catchBody": {
					"enum": [
						"same",
						"next",
						"keep"
					],
					"type": "string",
					"description": "same line policy for non block body of \"catch\"\n\t\t* same = place function and body on same line\n\t\t* next = place body on next line\n\t\t* keep = keep same / next line from source",
					"propertyOrder": 12
				}
			},
			"additionalProperties": false
		},
		"EmptyLinesConfig": {
			"type": "object",
			"properties": {
				"betweenSingleLineTypes": {
					"type": "integer",
					"description": "empty lines between two single line types",
					"propertyOrder": 6
				},
				"beforeBlocks": {
					"enum": [
						"keep",
						"remove"
					],
					"type": "string",
					"propertyOrder": 10
				},
				"betweenTypes": {
					"type": "integer",
					"description": "empty lines between types",
					"propertyOrder": 5
				},
				"afterLeftCurly": {
					"enum": [
						"keep",
						"remove"
					],
					"type": "string",
					"description": "Remove or keep empty lines below \"{\"",
					"propertyOrder": 8
				},
				"afterReturn": {
					"enum": [
						"keep",
						"remove"
					],
					"type": "string",
					"description": "Remove or keep empty lines below \"return\"",
					"propertyOrder": 9
				},
				"maxAnywhereInFile": {
					"type": "integer",
					"description": "maximum consecutive empty lines anywhere in file - runs last, all empty lines policies are limited to \"maxAnywhereInFile\"",
					"propertyOrder": 1
				},
				"enumAbstractEmptyLines": {
					"propertyOrder": 12,
					"$ref": "#/definitions/EnumAbstractFieldsEmptyLinesConfig"
				},
				"beforePackage": {
					"type": "integer",
					"description": "empty lines before package declaration",
					"propertyOrder": 2
				},
				"typedefEmptyLines": {
					"propertyOrder": 18,
					"$ref": "#/definitions/TypedefFieldsEmptyLinesConfig"
				},
				"interfaceEmptyLines": {
					"propertyOrder": 16,
					"$ref": "#/definitions/InterfaceFieldsEmptyLinesConfig"
				},
				"externClassEmptyLines": {
					"propertyOrder": 14,
					"$ref": "#/definitions/InterfaceFieldsEmptyLinesConfig"
				},
				"abstractEmptyLines": {
					"propertyOrder": 15,
					"$ref": "#/definitions/ClassFieldsEmptyLinesConfig"
				},
				"afterBlocks": {
					"enum": [
						"keep",
						"remove"
					],
					"type": "string",
					"propertyOrder": 11
				},
				"importAndUsing": {
					"description": "empty lines for package, import and using section",
					"propertyOrder": 4,
					"$ref": "#/definitions/ImportsEmptyLinesConfig"
				},
				"classEmptyLines": {
					"propertyOrder": 13,
					"$ref": "#/definitions/ClassFieldsEmptyLinesConfig"
				},
				"beforeDocCommentEmptyLines": {
					"enum": [
						"ignore",
						"none",
						"one"
					],
					"type": "string",
					"description": "\"one\" adds one empty line above doc comments\n\t\t\"none\" removes all empty lines above doc comments\n\t\t\"ignore\" respects empty lines set via \"betweenVars\", \"betweenFunctions\", etc.",
					"propertyOrder": 20
				},
				"finalNewline": {
					"type": "boolean",
					"description": "adds a final newline",
					"propertyOrder": 0
				},
				"enumEmptyLines": {
					"propertyOrder": 17,
					"$ref": "#/definitions/TypedefFieldsEmptyLinesConfig"
				},
				"afterPackage": {
					"type": "integer",
					"description": "empty lines after package declaration",
					"propertyOrder": 3
				},
				"conditionalsEmptyLines": {
					"propertyOrder": 19,
					"$ref": "#/definitions/ConditionalEmptyLinesConfig"
				},
				"beforeRightCurly": {
					"enum": [
						"keep",
						"remove"
					],
					"type": "string",
					"description": "Remove or keep empty lines above \"}\"",
					"propertyOrder": 7
				}
			},
			"additionalProperties": false
		},
		"ConditionalEmptyLinesConfig": {
			"type": "object",
			"properties": {
				"afterElse": {
					"type": "integer",
					"propertyOrder": 2
				},
				"afterError": {
					"type": "integer",
					"propertyOrder": 5
				},
				"beforeError": {
					"type": "integer",
					"propertyOrder": 4
				},
				"beforeElse": {
					"type": "integer",
					"propertyOrder": 1
				},
				"afterIf": {
					"type": "integer",
					"propertyOrder": 0
				},
				"beforeEnd": {
					"type": "integer",
					"propertyOrder": 3
				}
			},
			"additionalProperties": false
		},
		"ClassFieldsEmptyLinesConfig": {
			"type": "object",
			"properties": {
				"betweenStaticFunctions": {
					"type": "integer",
					"propertyOrder": 8
				},
				"afterStaticFunctions": {
					"type": "integer",
					"propertyOrder": 7
				},
				"afterVars": {
					"type": "integer",
					"propertyOrder": 6
				},
				"betweenFunctions": {
					"type": "integer",
					"propertyOrder": 10
				},
				"afterPrivateFunctions": {
					"type": "integer",
					"propertyOrder": 9
				},
				"beginType": {
					"type": "integer",
					"description": "add empty lines after opening \"{\" of type",
					"propertyOrder": 0
				},
				"afterStaticVars": {
					"type": "integer",
					"propertyOrder": 3
				},
				"afterPrivateVars": {
					"type": "integer",
					"propertyOrder": 4
				},
				"endType": {
					"type": "integer",
					"description": "add empty lines before closing \"}\" of type",
					"propertyOrder": 1
				},
				"betweenStaticVars": {
					"type": "integer",
					"propertyOrder": 2
				},
				"betweenVars": {
					"type": "integer",
					"propertyOrder": 5
				}
			},
			"additionalProperties": false
		},
		"WrapCondition": {
			"type": "object",
			"properties": {
				"cond": {
					"enum": [
						"itemCount >= n",
						"itemCount <= n",
						"anyItemLength >= n",
						"anyItemLength <= n",
						"totalItemLength >= n",
						"totalItemLength <= n",
						"lineLength >= n",
						"lineLength <= n"
					],
					"type": "string",
					"propertyOrder": 0
				},
				"value": {
					"type": "integer",
					"propertyOrder": 1
				}
			},
			"additionalProperties": false,
			"required": [
				"cond"
			]
		},
		"WhitespaceConfig": {
			"type": "object",
			"properties": {
				"whilePolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"propertyOrder": 22
				},
				"typeParamOpenPolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"description": "\"<\"",
					"propertyOrder": 8
				},
				"closingBracketPolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"description": "\"]\"",
					"propertyOrder": 3
				},
				"ternaryPolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"propertyOrder": 18
				},
				"functionTypeHaxe3Policy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"propertyOrder": 30
				},
				"typeHintColonPolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"propertyOrder": 16
				},
				"commaPolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"propertyOrder": 11
				},
				"openingParenPolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"description": "\"(\"",
					"propertyOrder": 0
				},
				"objectOpeningBracePolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"description": "\"{\" in object literal",
					"propertyOrder": 6
				},
				"typeCheckColonPolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"propertyOrder": 17
				},
				"arrowFunctionsPolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"propertyOrder": 29
				},
				"openingBracketPolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"description": "\"[\"",
					"propertyOrder": 2
				},
				"tryPolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"propertyOrder": 25
				},
				"typeParamClosePolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"description": "\">\"",
					"propertyOrder": 9
				},
				"objectFieldColonPolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"propertyOrder": 15
				},
				"closingBracePolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"description": "\"}\" except object literals",
					"propertyOrder": 5
				},
				"typeExtensionPolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"propertyOrder": 10
				},
				"semicolonPolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"propertyOrder": 19
				},
				"functionTypeHaxe4Policy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"propertyOrder": 31
				},
				"catchPolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"propertyOrder": 26
				},
				"binopPolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"propertyOrder": 27
				},
				"compressSuccessiveParenthesis": {
					"type": "boolean",
					"description": "should formatter compress spaces for successive parenthesis `( [ {` vs. `([{`",
					"propertyOrder": 32
				},
				"forPolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"propertyOrder": 23
				},
				"colonPolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"propertyOrder": 13
				},
				"doPolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"propertyOrder": 21
				},
				"switchPolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"propertyOrder": 24
				},
				"caseColonPolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"propertyOrder": 14
				},
				"closingParenPolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"description": "\")\"",
					"propertyOrder": 1
				},
				"openingBracePolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"description": "\"{\" except object literals",
					"propertyOrder": 4
				},
				"objectClosingBracePolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"description": "\"}\" in object literal",
					"propertyOrder": 7
				},
				"ifPolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"propertyOrder": 20
				},
				"intervalPolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"propertyOrder": 28
				},
				"formatStringInterpolation": {
					"type": "boolean",
					"description": "should formatter try to format string interpolation expressions (e.g. '${x+3}' -> '${x + 3}')\n\t\tonly applies spaces, no newlines or wrapping",
					"propertyOrder": 33
				},
				"dotPolicy": {
					"enum": [
						"none",
						"before",
						"noneBefore",
						"onlyBefore",
						"after",
						"onlyAfter",
						"noneAfter",
						"around"
					],
					"type": "string",
					"propertyOrder": 12
				}
			},
			"additionalProperties": false
		},
		"EnumAbstractFieldsEmptyLinesConfig": {
			"type": "object",
			"properties": {
				"afterVars": {
					"type": "integer",
					"propertyOrder": 3
				},
				"betweenFunctions": {
					"type": "integer",
					"propertyOrder": 4
				},
				"beginType": {
					"type": "integer",
					"description": "add empty lines after opening \"{\" of type",
					"propertyOrder": 0
				},
				"endType": {
					"type": "integer",
					"description": "add empty lines before closing \"}\" of type",
					"propertyOrder": 1
				},
				"betweenVars": {
					"type": "integer",
					"propertyOrder": 2
				}
			},
			"additionalProperties": false
		},
		"LineEndConfig": {
			"type": "object",
			"properties": {
				"emptyCurly": {
					"enum": [
						"noBreak",
						"break"
					],
					"type": "string",
					"propertyOrder": 8
				},
				"rightCurly": {
					"enum": [
						"none",
						"before",
						"after",
						"both"
					],
					"type": "string",
					"propertyOrder": 7
				},
				"metadataOther": {
					"enum": [
						"none",
						"after",
						"afterLast",
						"forceAfterLast"
					],
					"type": "string",
					"propertyOrder": 3
				},
				"leftCurly": {
					"enum": [
						"none",
						"after",
						"before",
						"both"
					],
					"type": "string",
					"propertyOrder": 6
				},
				"metadataType": {
					"enum": [
						"none",
						"after",
						"afterLast",
						"forceAfterLast"
					],
					"type": "string",
					"propertyOrder": 0
				},
				"sharp": {
					"enum": [
						"none",
						"after"
					],
					"type": "string",
					"propertyOrder": 5
				},
				"metadataVar": {
					"enum": [
						"none",
						"after",
						"afterLast",
						"forceAfterLast"
					],
					"type": "string",
					"propertyOrder": 1
				},
				"caseColon": {
					"enum": [
						"none",
						"after"
					],
					"type": "string",
					"propertyOrder": 4
				},
				"metadataFunction": {
					"enum": [
						"none",
						"after",
						"afterLast",
						"forceAfterLast"
					],
					"type": "string",
					"propertyOrder": 2
				}
			},
			"additionalProperties": false
		},
		"WrapConfig": {
			"type": "object",
			"properties": {
				"callParameter": {
					"description": "call parameter wrapping rules",
					"propertyOrder": 5,
					"$ref": "#/definitions/WrapRules"
				},
				"functionSignature": {
					"description": "named function signature wrapping rules",
					"propertyOrder": 3,
					"$ref": "#/definitions/WrapRules"
				},
				"typeParameter": {
					"description": "type parameter wrapping rules",
					"propertyOrder": 2,
					"$ref": "#/definitions/WrapRules"
				},
				"anonFunctionSignature": {
					"description": "anon function signature wrapping rules",
					"propertyOrder": 4,
					"$ref": "#/definitions/WrapRules"
				},
				"methodChain": {
					"description": "method chaining wrapping rules",
					"propertyOrder": 8,
					"$ref": "#/definitions/WrapRules"
				},
				"maxLineLength": {
					"type": "integer",
					"description": "maximum characters per line, formatter will try to wrap code longer than `maxLineLength`",
					"propertyOrder": 0
				},
				"anonType": {
					"description": "anon types wrapping rules",
					"propertyOrder": 7,
					"$ref": "#/definitions/WrapRules"
				},
				"objectLiteral": {
					"description": "object literal wrapping rules",
					"propertyOrder": 6,
					"$ref": "#/definitions/WrapRules"
				},
				"arrayWrap": {
					"description": "array wrapping rules\n\t\tdoes not affect array comprehension, use \"sameLine.comprehensionFor\"",
					"propertyOrder": 1,
					"$ref": "#/definitions/WrapRules"
				},
				"opBoolChain": {
					"description": "OpBool chain wrapping rules",
					"propertyOrder": 9,
					"$ref": "#/definitions/WrapRules"
				}
			},
			"additionalProperties": false
		},
		"ImportsEmptyLinesConfig": {
			"type": "object",
			"properties": {
				"beforeType": {
					"type": "integer",
					"description": "empty lines after import and using section",
					"propertyOrder": 3
				},
				"betweenImports": {
					"type": "integer",
					"description": "empty lines between two consecutive import/using lines using betweenImportsLevel",
					"propertyOrder": 0
				},
				"beforeUsing": {
					"type": "integer",
					"description": "empty lines between import and using lines",
					"propertyOrder": 2
				},
				"betweenImportsLevel": {
					"enum": [
						"all",
						"firstLevelPackage",
						"secondLevelPackage",
						"thirdLevelPackage",
						"fourthLevelPackage",
						"fifthLevelPackage",
						"fullPackage"
					],
					"type": "string",
					"description": "restrict betweenImports setting to a specific level\n\t\t\"all\" - apply betweenImports to all imports/using entries\n\t\t\"topLevelPackage\" - group imports/using entries using toplevel package names; no empty lines for identical toplevel names\n\t\t\"packages\" - group imports/using entries using full packages; no empty lines for identical package names",
					"propertyOrder": 1
				}
			},
			"additionalProperties": false
		},
		"WrapRules": {
			"type": "object",
			"properties": {
				"rules": {
					"items": {
						"$ref": "#/definitions/WrapRule"
					},
					"type": "array",
					"description": "list of wrapping rules\n\t\twrapping uses only the first rule whose conditions evaluates to true",
					"propertyOrder": 0
				},
				"defaultAdditionalIndent": {
					"type": "integer",
					"description": "adds indentation to all wrapped lines when applying defaultWrap",
					"propertyOrder": 2
				},
				"defaultWrap": {
					"enum": [
						"onePerLine",
						"onePerLineAfterFirst",
						"equalNumber",
						"fillLine",
						"noWrap",
						"keep"
					],
					"type": "string",
					"description": "default wrapping type when no rule applies",
					"propertyOrder": 1
				}
			},
			"additionalProperties": false
		}
	}
}